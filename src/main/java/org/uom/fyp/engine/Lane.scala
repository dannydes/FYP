package org.uom.fyp.engine

/**
 * Created by Daniel on 5/4/2015.
 * @param laneNo Lane's number as represented in the corresponding Street object. Used for
 *               the purpose of lane identification.
 * @param l Lane's length.
 */
class Lane(laneNo: Int, l: Double) {

  /**
   * Stores lane slices that are generated by the class.
   */
  private var laneSlices: List[LaneSlice] = List()

  /**
   * Stores the lane's length.
   */
  private var len = l

  /**
   * Returns the lane's length as represented in the corresponding Street object.
   */
  def no = laneNo

  /**
   * Returns the lane's length.
   */
  def length = len

  /**
   * Sets the lane's length.
   * @param l The lane's length.
   */
  def length_(l: Double) = {
    len = l
  }

  /**
   * Adds a lane slice to be added to the
   * @param otherAttachedAt
   * @param nextOtherAttachedAt
   */
  def addEdge(otherAttachedAt: Double, nextOtherAttachedAt: Double = len): LaneSlice = {
    if (nextOtherAttachedAt > len) {
      throw new LaneLengthExceededException(nextOtherAttachedAt)
    }

    val laneSlice: LaneSlice = new LaneSlice
    laneSlice.length_(nextOtherAttachedAt - otherAttachedAt)
    laneSlices = laneSlices ++ List(laneSlice)

    laneSlice
  }

  /**
   * Returns a list containing the slices sliced off the lane.
   */
  def edges = laneSlices

  /**
   * Initializes values to be used during simulation.
   * @param vehicles The number of vehicles fed into the lane.
   * @param arrivalRate The lane's arrival rate.
   */
  def initialize(vehicles: Int, arrivalRate: Double) = {
    val pFlowInOut = vehicles / laneSlices.length
    var v = vehicles
    laneSlices.foreach((edge: LaneSlice) => {
      edge.noOfVehicles_(v)
      v -= pFlowInOut
    })
  }

  /**
   *
   * @param network
   * @param streetName
   * @param streetType
   * @param length
   * @param point
   * @return
   */
  def attachLane(network: RoadNetwork, streetName: String, streetType: StreetType,
                 length: Double, point: Double): Lane = {
    val street: Street = network.addStreet(streetName, streetType)
    val lane: Lane = new Lane(street.lanes.length, length)

    street.addLane(lane)

    var otherAt = 0.0
    if (this.laneSlices.length != 0) {
      val prev: LaneSlice = this.laneSlices(this.laneSlices.length - 1)
      otherAt = prev.intersectionPoint + prev.length
    }

    val edge: LaneSlice = addEdge(otherAt, point)
    edge.laneAtTarget_(lane)
    edge.otherIntersectionPoint_(0)

    lane
  }

  def createLastEdge() = {
    if (laneSlices.length == 0) {
      addEdge(0, length)
    } else {
      val lastEdge: LaneSlice = laneSlices(laneSlices.length - 1)
      val point = lastEdge.intersectionPoint + lastEdge.length
      if (point < length) {
        val edge: LaneSlice = addEdge(point, length)
      }
    }
  }

  def getEdge(otherIntersectionPoint: Double): LaneSlice = {
    laneSlices.filter((edge: LaneSlice) => edge.intersectionPoint == otherIntersectionPoint)(0)
  }

}
