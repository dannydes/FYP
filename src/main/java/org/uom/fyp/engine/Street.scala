package org.uom.fyp.engine

/**
 * Applies operations over streets.
 * @param streetName The name of the street.
 * @param sType The type of the street.
 * @param len The length of the street.
 * @param lanes The number of lanes the street has.
 */
class Street(streetName: String, sType: StreetType, len: Double, lanes: Int = 1) {

  /**
   * Stores lane slices that are generated by the class.
   */
  private var laneSlices: List[Edge] = List()

  /**
   * Returns the name of the street.
   */
  def name = streetName

  /**
   * Returns the type of the street.
   */
  def streetType = sType

  /**
   * Returns the length of the street.
   */
  def length = len

  /**
   * Returns the number of lanes the street has.
   */
  def noOfLanes = lanes

  /**
   * Adds a lane slice to be added to the graph later on.
   * @param otherAttachedAt The point where the attachment takes place.
   * @param nextOtherAttachedAt The next point where the attachment takes place.
   *                            Defaults to the length of the context length if
   *                            omitted.
   * @return The edge that has been created and added to the graph.
   */
  def addEdge(otherAttachedAt: Double, nextOtherAttachedAt: Double = len): Edge = {
    if (nextOtherAttachedAt > len) {
      throw new StreetLengthExceededException(nextOtherAttachedAt)
    }

    val laneSlice: Edge = new Edge
    laneSlice.length_(nextOtherAttachedAt - otherAttachedAt)
    laneSlice.streetName_(streetName)
    laneSlices = laneSlices ++ List(laneSlice)

    laneSlice
  }

  /**
   * Returns a list containing the slices sliced off the street.
   */
  def edges = laneSlices

  /**
   * Initializes values to be used during simulation.
   * @param vehicles The number of vehicles fed into the street.
   * @param arrivalRate The street's arrival rate.
   */
  def initialize(vehicles: Int, arrivalRate: Double) = {
    val pFlowInOut = vehicles / laneSlices.length
    var v = vehicles
    laneSlices.foreach((edge: Edge) => {
      edge.noOfVehicles_(v)
      v -= pFlowInOut
    })
  }

  /**
   * Creates and attaches an outgoing street to the context street.
   * @param network The network where the street will be attached.
   * @param streetName The name of the street to be attached.
   * @param streetType The type of the street to be attached.
   * @param length The length the street to be attached.
   * @param point The point where the street is to be attached with respect to
   *              the starting point of the other.
   * @return The street that has been created.
   */
  def attachStreet(network: RoadNetwork, streetName: String, streetType: StreetType,
                 length: Double, point: Double): Street = {
    val street: Street = network.addStreet(streetName, streetType, length)

    var otherAt = 0.0
    if (this.laneSlices.length != 0) {
      val prev: Edge = this.laneSlices(this.laneSlices.length - 1)
      otherAt = prev.intersectionPoint + prev.length
    }

    val edge: Edge = addEdge(otherAt, point)
    edge.streetAtTarget_(street)
    edge.otherIntersectionPoint_(0)

    street
  }

  /**
   * Creates the last edge in a road by determining the position of the last
   * intersection on that road. This method should be called after all road
   * attachments in the model have taken place upon the context road. In case
   * no attachments have been carried out on the context road, a single edge
   * would be created.
   */
  def createLastEdge() = {
    if (laneSlices.length == 0) {
      addEdge(0, length)
    } else {
      val lastEdge: Edge = laneSlices(laneSlices.length - 1)
      val point = lastEdge.intersectionPoint + lastEdge.length
      if (point < length) {
        val edge: Edge = addEdge(point, length)
      }
    }
  }

  /**
   * Returns the edge at a given intersection point on the other road.
   * @param otherIntersectionPoint Intersection point on the other road.
   */
  def getEdge(otherIntersectionPoint: Double): Edge = {
    laneSlices.filter((edge: Edge) => edge.intersectionPoint == otherIntersectionPoint)(0)
  }

  /**
   * Blocks the street.
   * @param network The road network in which the street is found.
   */
  def block(network: RoadNetwork): Unit = {

  }

}
