package org.uom.fyp.dslfrontend

import org.uom.fyp.engine.StreetType.StreetType
import org.uom.fyp.engine.{RoadStructure, Street, StreetType, RoadNetwork}

import scala.util.parsing.combinator.JavaTokenParsers
import scala.io.Source

/**
 * Forms a parse tree and initiates actions responding to the structure of the program being
 * parsed.
 */
object Parser extends JavaTokenParsers {

  private var network: RoadNetwork = _

  /**
   * Returns a pointer to the graph generated by the parser representing the network
   * described by the given model.
   */
  def networkGraph = network

  private def attachRoadHelper(road: String, streetType: StreetType, len: String, vehiclesL: String, arrivalRateL: String, vehiclesR: String, arrivalRateR: String, pos: String, lanes: String, to: String) = {
    (if (to == "") network.streetList(0) else network.getStreet(to)).attachStreet(network, road, streetType, parseDouble(len).toList(0), parseDouble(pos).toList(0), parseInt(vehiclesL).toList(0), parseDouble(arrivalRateL).toList(0), parseInt(vehiclesR).toList(0), parseDouble(arrivalRateR).toList(0), parseInt(lanes).toList(0))
  }

  private def parseDouble(s: String) = try { Some(s.toDouble) } catch { case _: Throwable => None }

  private def parseInt(s: String) = try { Some(s.toInt) } catch { case _: Throwable => None }

  /**
   * Parses a whole model.
   * @return Parser for model.
   */
  def model = constructNetwork ~ definitions ~ runSimulation ~ modifications.?

  /**
   * Parses the <b>construct network</b> construct, as well as starts creating
   * the network.
   * @return Parser for network construction.
   */
  def constructNetwork = ("construct" ~> "network" ~> ident <~ "(") ^^
    { case n => network = new RoadNetwork(n) }

  /**
   * Parses the <b>run simulation</b> construct.
   * @return Parser to run the simulation.
   */
  def runSimulation = ("run" ~> "simulation" ~> "for" ~> "minutes" ~> floatingPointNumber) ^^ {
    case minutes => network.simulate(parseDouble(minutes).toList(0))
  }

  /**
   * Parses actions related to road network construction, such as <b>create road</b>.
   * @return Parser for the actions related to road network construction.
   */
  def definitions = createRoad ~ (attachRoad | crossroad | roundabout | createRoad).* ~ ")" ^^ {
    case _ => {
      network.completeEdgeList()
      network.buildGraph()
    }
  }

  /**
   * Parses the <b>create primary road</b> construct, together with its properties.
   * @return Parser for road creation.
   */
  def createRoad = ("create" ~> "primary") ~ ("road" ~> ident) ~ ("with" ~> "length" ~> floatingPointNumber) ~
    ("left" ~> "has" ~> "vehicles" ~> wholeNumber) ~ ("arrival" ~> "rate" ~> floatingPointNumber) ~
    ("right" ~> "has" ~> "vehicles" ~> wholeNumber) ~ ("arrival" ~> "rate" ~> floatingPointNumber) ~ ("lanes" ~> wholeNumber).? ^^ {
    case "primary" ~ road ~  len ~ vehiclesL ~ arrivalRateL ~ vehiclesR ~ arrivalRateR ~ lanes => {
      network.createStreet(road, StreetType.PRIMARY, parseDouble(len).toList(0), parseInt(vehiclesL).toList(0), parseDouble(arrivalRateL).toList(0), parseInt(vehiclesR).toList(0), parseDouble(arrivalRateR).toList(0), parseInt(lanes.getOrElse("1")).toList(0))
    }
  }

  /**
   * Parses the <b>attach primary/secondary road</b> construct, together with its properties.
   * @return Parser for road attachment.
   */
  def attachRoad = ("attach" ~> ("primary" | "secondary")) ~ ("road" ~> ident) ~ ("with" ~> "length" ~> floatingPointNumber) ~ ("to" ~> ident).? ~
    ("at" ~> floatingPointNumber) ~ ("left" ~> "has" ~> "vehicles" ~> wholeNumber) ~ ("arrival" ~> "rate" ~> floatingPointNumber) ~
    ("right" ~> "has" ~> "vehicles" ~> wholeNumber) ~ ("arrival" ~> "rate" ~> floatingPointNumber) ~ ("lanes" ~> wholeNumber).? ^^
    {
      case "primary" ~ road ~ len ~ to ~ pos ~ vehiclesL ~ arrivalRateL ~ vehiclesR ~ arrivalRateR ~ lanes => attachRoadHelper(road, StreetType.PRIMARY, len, vehiclesL, arrivalRateL, vehiclesR, arrivalRateR, pos, lanes.getOrElse("1"), to.getOrElse(""))
      case "secondary" ~ road ~ len ~ to ~ pos ~ vehiclesL ~ arrivalRateL ~ vehiclesR ~ arrivalRateR ~ lanes => attachRoadHelper(road, StreetType.SECONDARY, len, vehiclesL, arrivalRateL, vehiclesR, arrivalRateR, pos, lanes.getOrElse("1"), to.getOrElse(""))
    }

  /**
   * Parses the <b>crossroad</b> statement.
   * @return Parser for the crossroad statement.
   */
  def crossroad = ("crossroad" ~> ident) ~ ("at" ~> floatingPointNumber) ~ ("wait" ~> floatingPointNumber) ~ ("with" ~> ident) ~ ("at" ~> floatingPointNumber) ~ ("wait" ~> floatingPointNumber) ^^
    {
      case road ~ pos ~ timing ~ otherRoad ~ otherPos ~ otherTiming => {
        RoadStructure.Crossroads.addTimingPair(road, otherRoad, parseDouble(timing).toList(0), parseDouble(otherTiming).toList(0))
        network.getStreet(road).createCrossroads(parseDouble(pos).toList(0), network.getStreet(otherRoad), parseDouble(otherPos).toList(0))
      }
    }

  /**
   * Parses the <b>roundabout</b> statement.
   * @return Parser for the roundabout statement.
   */
  def roundabout = ("roundabout" ~> "on" ~> ident) ~ ("at" ~> floatingPointNumber) ~ ("exit" ~> "rate" ~> floatingPointNumber) ^^
    {
      case road ~ pos ~ exitRate => {
        RoadStructure.Roundabout.addExitRate(road, parseDouble(pos).toList(0), parseDouble(exitRate).toList(0))
        network.getStreet(road).createRoundabout(parseDouble(pos).toList(0))
      }
    }

  /**
   * Parses the <b>block</b> construct.
   * @return Parser for blocking.
   */
  def blockRoad = ("block" ~> ident) ^^ { case road => network.blockStreet(road) }

  /**
   * Parses the <b>change</b> construct.
   * @return Parser for changes to road definitions.
   */
  def change = ("change" ~> ident) ~ ("lanes" ~> floatingPointNumber) ^^
    { case road ~ lanes => network.getStreet(road).noOfLanes_(parseInt(lanes).toList(0)) }

  /**
   * Parses the modifications defined and the <b>rerun</b> statement.
   * @return Parser for modifications.
   */
  def modifications = (blockRoad | change | roundabout).+ ~ "rerun" ^^ { case _ => network.simulate() }

  /**
   * Initializes the parsing process for some source file with the given
   * filename.
   * @param filename The filename of the file to be parsed.
   */
  def parse(filename: String) = {
    parseAll(model, Source.fromFile(filename).mkString) match {
      case Success(query, _) => println("Model execution complete!")
      case Failure(msg, _) => println(msg)
      case Error(msg, _) => println(msg)
    }
  }

}
